// WhatsApp PWA - Prisma Schema
// Optimized for 10,000+ concurrent users with connection pooling and indexing

generator client {
  provider = "prisma-client-js"
  // Optimize for production performance
  previewFeatures = ["fullTextSearch"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // Connection pooling configuration for high concurrency
  // Vercel Postgres automatically handles connection pooling
  // For self-hosted: use PgBouncer or similar
}

// ============================================================================
// USER MODEL - Stores user account information
// Optimized for fast lookups and online status queries
// ============================================================================
model User {
  id            String    @id @default(cuid())
  phoneNumber   String    @unique @db.VarChar(20)
  password      String    @db.VarChar(255)
  displayName   String?   @db.VarChar(255)
  profileImage  String?   @db.Text
  status        String?   @default("Hey there! I'm using WhatsApp.") @db.VarChar(500)
  isOnline      Boolean   @default(false) @db.Boolean
  lastSeen      DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // E2E Encryption - Public key for key exchange (stored as JSON string)
  publicKey     String?   @db.Text

  // Relations
  sentMessages      Message[]     @relation("sender")
  receivedMessages  Message[]     @relation("receiver")
  contacts          Contact[]     @relation("user")
  contactOf         Contact[]     @relation("contact")

  // Indexes for fast queries
  @@index([phoneNumber])
  @@index([isOnline])
  @@index([createdAt])
  @@index([lastSeen])
}

// ============================================================================
// CONTACT MODEL - Stores user's contact list
// Optimized for fast contact lookups and filtering
// ============================================================================
model Contact {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation("user", fields: [userId], references: [id], onDelete: Cascade)
  contactId String
  contact   User     @relation("contact", fields: [contactId], references: [id], onDelete: Cascade)
  nickname  String?  @db.VarChar(255)
  createdAt DateTime @default(now())

  // Unique constraint to prevent duplicate contacts
  @@unique([userId, contactId])
  
  // Indexes for fast queries
  @@index([userId])
  @@index([contactId])
  @@index([createdAt])
}

// ============================================================================
// CONVERSATION MODEL - Represents a 1-on-1 chat
// Optimized for fast conversation lookups and message retrieval
// ============================================================================
model Conversation {
  id            String    @id @default(cuid())
  participant1Id String
  participant2Id String
  lastMessage   String?   @db.Text
  lastMessageAt DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  messages      Message[]

  // Unique constraint to prevent duplicate conversations
  @@unique([participant1Id, participant2Id])
  
  // Indexes for fast queries
  @@index([participant1Id])
  @@index([participant2Id])
  @@index([lastMessageAt])
  @@index([updatedAt])
}

// ============================================================================
// MESSAGE MODEL - Stores individual messages
// Optimized for fast message retrieval and pagination
// ============================================================================
model Message {
  id              String   @id @default(cuid())
  conversationId  String
  conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  senderId        String
  sender          User     @relation("sender", fields: [senderId], references: [id], onDelete: Cascade)
  receiverId      String
  receiver        User     @relation("receiver", fields: [receiverId], references: [id], onDelete: Cascade)
  
  // Message content (plaintext - for backward compatibility)
  content         String   @db.Text
  
  // E2E Encryption fields (added for encryption support)
  encryptedContent String? @db.Text  // Encrypted message content
  isEncrypted     Boolean  @default(false) @db.Boolean  // Whether message is encrypted
  iv             String?  @db.Text  // Initialization vector for decryption
  
  // Media
  mediaUrl        String?  @db.Text
  mediaType       String?  @db.VarChar(50) // "image", "video", "document", etc.
  
  // Message status
  status          String   @default("sent") @db.VarChar(20) // "sent", "delivered", "read"
  isDeleted       Boolean  @default(false) @db.Boolean
  
  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  readAt          DateTime?

  // Indexes for fast queries
  @@index([conversationId])
  @@index([senderId])
  @@index([receiverId])
  @@index([createdAt])
  @@index([status])
  // Composite index for common query patterns
  @@index([conversationId, createdAt])
}

// ============================================================================
// SESSION MODEL - NextAuth.js session management
// Optimized for fast session lookups
// ============================================================================
model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  createdAt    DateTime @default(now())

  // Indexes for fast queries
  @@index([userId])
  @@index([expires])
}

// ============================================================================
// VERIFICATION TOKEN MODEL - Phone number verification
// Optimized for fast token lookups and expiration cleanup
// ============================================================================
model VerificationToken {
  id        String   @id @default(cuid())
  phone     String   @unique @db.VarChar(20)
  token     String   @unique
  expires   DateTime
  createdAt DateTime @default(now())

  // Indexes for fast queries
  @@index([phone])
  @@index([expires])
}

// ============================================================================
// PERFORMANCE NOTES FOR 10,000+ CONCURRENT USERS:
// ============================================================================
// 1. CONNECTION POOLING:
//    - Vercel Postgres: Automatic connection pooling (built-in)
//    - Self-hosted: Use PgBouncer with min_pool_size=20, max_pool_size=100
//
// 2. INDEXES:
//    - All foreign keys are indexed for fast joins
//    - Composite indexes on common query patterns
//    - Indexes on frequently filtered columns (isOnline, status, createdAt)
//
// 3. QUERY OPTIMIZATION:
//    - Use pagination for message retrieval (limit 50 per page)
//    - Cache user online status in Redis if possible
//    - Use database connection pooling for concurrent requests
//
// 4. SCALING STRATEGIES:
//    - Read replicas for analytics queries
//    - Caching layer (Redis) for frequently accessed data
//    - Message archival for old conversations
//    - Sharding by user ID for extreme scale (100k+ users)
//
// 5. MONITORING:
//    - Monitor connection pool usage
//    - Track slow queries (>100ms)
//    - Monitor database CPU and memory
//    - Set up alerts for connection pool exhaustion
// ============================================================================
